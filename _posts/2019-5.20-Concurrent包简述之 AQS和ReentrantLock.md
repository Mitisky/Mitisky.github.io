---
layout: post
title:  "Concurrent包简述之 AQS和ReentrantLock"
date:   2019-5-20  +0800
categories:  多线程
---


Concurrent包中提供的是每一名java的开发者必定会使用到的工具，而AbstractQueuedSynchronizer对象是concurrent包中多种多样工具基石。

## AQS（AbstractQueuedSynchronizer）
AQS为并发问题提供了一个高效且易扩展的基础。许多特定场景锁都是基于AQS实现的。其组成包括以下几部分

1. 状态位，表示当前状态，例如在`ReentrantLock`中0表示可获得当前锁，1表示被占用。
2. 等待队列，基于CLH锁队列的改进。简单点说就是当前线程如果获得锁失败，那么就加入等待队列等待唤醒。

## 实现简述（ReentrantLock）
为什么是简述呢？我觉得如果不是处理问题等特殊需求，分析代码实现并没有太多作用。基本写下来之后回顾也无太多加载。反而是其实现主干，代码实现者隐藏在代码细节下的模式，才会最终对自己编码能力有所提高，以后回顾起来也更有价值。
由于ReentrantLock几乎人人用过，因此通过ReentrantLock来说简述AQS更加有代入感。一个加锁过程如下：

* 每个线程去lock的时候，其实是利用CAS方式尝试改变AQS中的状态位。
* 成功改变的线程意味着当前线程获得了锁
* 改变失败的线程就创建一个Node加入等待队列，并主动挂起自己。

在线程池一文中已经写过并发包中实现的模式，这里其实并无太大变化。这里主要简述等待队列中用到的模式。

### 等待队列的链表
实现过线程安全链表的同学，应该都会使用lock来达到线程安全。简单一点实现如下
* 在读取部分上锁是为了确保读到最新的状态，也就是保证可见性。
* 在写入部分上锁，更多是为了避免竞态。
这样实现非常简单但不高效，主要因为颗粒度太粗。

而这里是lock中的链表肯定是无法使用lock来实现的了，那必然有其他方法做的。其实现如下：

* 所有可见性还是通过Volatile来做到，例如head，next等链表node的对象都是volatile变量。这样read过程就可以避免上锁。
* 所有的写入操作都通过CAS来实现。这里使用的是`public final native boolean compareAndSwapObject(Object var1, long var2, Object var4, Object var5)`需用通过对象属性偏移量来改变value

这样实现对于性能主要影响在于volatile变量每次读写都是走主存，和CAS这部分的影响。但是其带来非常细腻的颗粒度，因此其它线程的等待时间是非常短暂。
当然我们在实现中一般没有必要使用底层这些底层方法，通过Lock锁对象尽量降低颗粒度也是可以达到很好性能。






